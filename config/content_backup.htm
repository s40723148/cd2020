<h1>About</h1>
<p><span>Repository：<a href="https://github.com/s40723148/cd2020">https://github.com/s40723148/cd2020</a></span></p>
<p><span></span>Blog：<a href="https://s40723148.github.io/cd2020/blog/i">https://s40723148.github.io/cd2020/blog/i</a></p>
<p>Group  <span>Repository：<a href="https://github.com/s40723150/cd2020ag2">https://github.com/s40723150/cd2020ag2</a></span></p>
<p><span>Group web：<a href="https://s40723150.github.io/cd2020ag2/" rel="nofollow">https://s40723150.github.io/cd2020ag2/</a></span></p>
<p><span>Youtube：<a href="https://www.youtube.com/channel/UCSEHMzQJcC2zslpQgoBFKuA?view_as=subscriber">https://www.youtube.com/channe</a></span></p>
<p><big><big><big>課程進度</big></big></big></p>
<p><span style="background-color: #ffff00;"><big><big>Assignment 1:</big></big></span></p>
<p>Due March 25, 2020 for class 2a .</p>
<p>What do you need to know from <a href="http://www.coppeliarobotics.com/helpFiles/index.html" rel="nofollow">http://www.coppeliarobotics.com/helpFiles/index.html</a> to implement a four-wheeled robot?</p>
<p><span style="background-color: #ffff00;"><big><big>Assignment 2:</big></big></span></p>
<p>Due April 22, 2020 for class 2a.</p>
<ol>
<li>
<p>According to the material of Topic 0 and Topic 1, can you describe specifically what the mechanical design team need to do for accomplishing Assignment 1's four wheeled robot.</p>
</li>
<li>
<p>What do you need to know from<span> </span><a href="https://cyberbotics.com/doc/guide/index" rel="nofollow">https://cyberbotics.com/doc/guide/index</a><span> </span>to implement a four-wheeled robot?</p>
</li>
</ol>
<p><span style="background-color: #ffff00;"><big><big>Assignment 3:</big></big></span></p>
<p>Due May 27, 2020 for class 2a.</p>
<p>According to the reading of Topic 2 and Topic 3, propose a Mechatronic project by using CoppeliaSim or Webots and Onshape.</p>
<h1>Four-wheeled robot</h1>
<p><big><big>Task members</big></big></p>
<p><span>Repository: </span><a href="https://github.com/40623143/cd2020">40623143</a><span><span> </span>| Site:<span> </span></span><a href="https://40623143.github.io/cd2020">40623143</a></p>
<p><span>Repository: </span><a href="https://github.com/s40723143/cd2020">40723143</a><span><span> </span>| Site:<span> </span></span><a href="https://s40723143.github.io/cd2020">40723143</a><span> </span></p>
<p><span>Repository: <a href="https://github.com/s40723144/cd2020">40723144</a><span><span> </span>| Site:<span> </span></span><a href="https://s40723144.github.io/cd2020">40723144</a></span></p>
<p></p>
<h2>CoppeliaSim</h2>
<p><big><big><a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> </big></big>(<a href="https://www.coppeliarobotics.com/downloads">download</a>)</p>
<p style="text-align: justify;">具有集成開發環境的機器人模擬器CoppeliaSim基於分佈式控制體系結構：可以通過嵌入式腳本，插件，ROS節點，BlueZero節點，遠程API客戶端或自定義解決方案分別控制每個對象/模型。這使CoppeliaSim非常通用，非常適合多機器人應用。控制器可以用C / C ++，Python，Java，Lua，Matlab，Octave或Urbi編寫。</p>
<p style="text-align: justify;">Coppelia Robotics 在 <a href="https://www.coppeliarobotics.com/helpFiles/en/versionInfo.htm">CoppeliaSim version history</a> 中提到將不再更新 V-rep <span lang="zh-TW">,並將精力集中在CoppeliaSim上。CoppeliaSim與V-REP 100％兼容。<span style="background-color: #ffff99;">它運行速度比V-REP快，並且具有更多功能</span>。</span></p>
<p style="text-align: justify;"><span lang="zh-TW">==================================================================</span></p>
<p style="text-align: justify;"><span lang="zh-TW">利用</span>CoppeliaSim進行四輪車模擬前，需要先了解其特色及其基本設置/功能：</p>
<p style="text-align: justify;"><span>1.跨平台支援</span></p>
<p style="text-align: justify;"><span>2.支援六種撰寫程式的方式<span><span> </span></span></span></p>
<p style="text-align: justify;"><span><span><span>3.支援6種程式語言</span></span></span></p>
<p style="text-align: justify;"><span><span><span>4.具備完整的運動學計算器<span><span> </span></span></span></span></span></p>
<p style="text-align: justify;"><span><span><span><span><span>5.支援路線及運動完整規劃</span></span></span></span></span></p>
<p style="text-align: justify;"><span><span><span><span><span>6.支援 <a href="https://en.wikipedia.org/wiki/Remote_Application_Programming_Interface">Remote API</a></span></span></span></span></span></p>
<p style="text-align: justify;"><span><span><span><span><span>及<a href="https://www.coppeliarobotics.com/helpFiles/en/coppeliaSimFeatures.htm">其他特色</a></span></span></span></span></span></p>
<p style="text-align: justify;">基本設置/功能可分成以下：</p>
<p style="text-align: justify;">1.模擬環境 </p>
<p style="text-align: justify;">2.力學分析</p>
<p style="text-align: justify;">3.代碼編寫</p>
<p style="text-align: justify;">4.模擬</p>
<p style="text-align: justify;"></p>
<h3>場景&amp;模型&amp;環境</h3>
<p><span style="background-color: #ffff00;"><big><big>Scenes</big></big></span></p>
<p style="text-align: justify;">場景和模型是CoppeliaSim的主要模擬元素。模型是場景的子元素。一個場景可以包含任何數量的模型</p>
<p><span style="background-color: #ffff00;"><big><big>Models</big></big></span></p>
<p style="text-align: justify;">模型是場景的子元素。除了文件（“ * .ttm”-文件類型）外，模型本身不能存在，也不能通過自身進行模擬。模型必須包含在場景中才能運行<span>。下圖為scenes &amp; Models 之間的關係:</span></p>
<p><span><img alt="" height="473" src="/images/chrome_2020-03-24_00-39-57.png" width="524"/></span></p>
<p><span style="background-color: #ffff00;"><big><big>Environment</big></big></span></p>
<p style="text-align: justify;">CoppeliaSim中的環境定義了屬於場景但不屬於場景物件的屬性和參數。保存模型時不保存環境屬性和參數，但只有保存場景則會</p>
<h3>Calculation modules</h3>
<p><span style="background-color: #ffff00;"><big><big>Collision detection</big></big></span></p>
<p>CoppeliaSim可以非常靈活的方式檢測兩個可碰撞實體之間的碰撞。 該計算是精確的干擾計算。 碰撞檢測模塊將僅檢測碰撞； 但是它不會直接對它們做出反應（有關碰撞響應，請參見<a href="https://www.coppeliarobotics.com/helpFiles/en/dynamicsModule.htm">dynamics module</a>）。</p>
<p><span style="background-color: #ffff00;"><big><big>Distance calculation</big></big></span></p>
<p>CoppeliaSim可以非常靈活的方式測量兩個可測量實體之間的最小距離。 該計算是精確的最小距離計算。 距離計算模塊將僅測量距離； 但是它不會直接對他們做出反應。</p>
<p><span style="background-color: #ffff00;"><big><big>Inverse kinematics</big></big></span></p>
<p>CoppeliaSim的逆運動學（IK）計算模塊非常強大且靈活。 它允許以逆運動學模式（IK模式）或正向運動學模式（FK模式）處理幾乎任何類型的機構。IK問題可以看作是找到與給定本體元素（通常是末端執行器）的某些特定位置和/或方向相對應的關節值之一。 一般而言，它是從任務空間坐標到關節空間坐標的轉換。例如，對於串接式機械手臂，問題將是在給定末端執行器的位置（和/或方向）的情況下找到操縱器中所有關節的值。 相反的在給定關節值的情況下找到末端執行器的位置-被稱為FK問題，通常被認為比IK更容易完成。在處理開放式運動學系列時，這確實是正確的，但對於一般類型的機械配置卻不成立，例如以下所示：</p>
<p>參考：<a href="https://www.coppeliarobotics.com/helpFiles/en/graphs.htm">graphs</a> ＆ <a href="https://www.coppeliarobotics.com/helpFiles/en/dataStreamTypes.htm">graph data stream types</a></p>
<p>運動學功能也可用於獨立應用程序（即，不直接屬於CoppeliaSim框架的應用程序，例如另一台計算機，機器人或控制器上的應用程序）。 通過<a href="https://www.coppeliarobotics.com/helpFiles/index.html">Coppelia運動學例程</a>可以做到這一點。</p>
<p><span style="background-color: #ffff00;"><big><big>Dynamics</big></big></span></p>
<p style="text-align: justify;">CoppeliaSim的動力學模塊當前支持下列四種不同的物理引擎。用戶在任何時候都可以根據自己的仿真需求自由地從一種發動機快速切換到另一種發動機。物理引擎支持如此多樣化的原因是，物理模擬是一項複雜的任務，可以通過不同程度的精度，速度或支持多種功能來實現：</p>
<ul>
<ul>
<ul>
<li>
<p style="text-align: justify;"><a href="http://www.bulletphysics.org/">Bullet physics library</a><span>:</span></p>
<p style="text-align: justify;">一個開源物理引擎，具有3D碰撞檢測，剛體動力學和<span>soft body dynamics</span>（CoppeliaSim當前不支持該功能）。它用於遊戲和電影的視覺效果。它通常被視為遊戲物理引擎。</p>
</li>
<li>
<p style="text-align: justify;"><span><a href="http://www.ode.org/">Open Dynamics Engine (ODE)</a><span>:</span></span></p>
一個具有兩個主要組成部分的開源物理引擎：剛體動力學和碰撞檢測。它已在許多應用程序和遊戲中使用。它通常被視為遊戲物理引擎。</li>
<li>
<p style="text-align: justify;"><span><span><a href="https://www.cm-labs.com/vortex-studio/">VortexÂ® Studio</a><span>:<span> </span></span></span></span></p>
非開源商業物理學引擎，可產生高保真物理模擬。 Vortex提供了大量物理屬性的實際參數（即對應於物理單位），使該引擎既逼真又精確。 Vortex主要用於高性能/高精度工業和研究應用。 CoppeliaSim的Vortex插件基於Vortex Studio，該插件要求每個用戶向CM Labs註冊以獲取免費許可證密鑰。</li>
<li>
<p style="text-align: justify;"><span><span><span><a href="http://www.newtondynamics.com/">Newton Dynamics</a><span>:<span> </span></span></span></span></span></p>
Newton Dynamics是一個跨平台的逼真的物理模擬文庫。它實現了確定性求解器，它不是基於傳統的LCP或<a href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3">疊代</a>方法，而是分別具有兩者的穩定性和速度。這項功能使Newton Dynamics不僅成為遊戲的工具，而且還成為任何實時物理模擬的工具。當前的插件執行是BETA版本。</li>
</ul>
</ul>
</ul>
<h3>編寫代碼</h3>
<p>CoppeliaSim是高度可定制的模擬器：可以自定義模擬的每個方面。此外，模擬器本身可以進行定制，以使其性能完全符合要求。這可以通過精心設計的應用程序編程接口（API）來實現。支持六種不同的編程或編碼方法，每種方法都具有相對於其他方法的特殊優點&amp;缺點，但所有六種方法都是相互兼容的（即可以同時使用，甚至可以穿插使用）。模型，場景或模擬器本身的控制實體可以位於以下位置：</p>
<ul>
<li><span>an </span><a href="https://www.coppeliarobotics.com/helpFiles/en/scripts.htm">embedded script</a><span><span> :此方法非常容易且靈活，可以保證與其他所有默認的CoppeliaSim安裝兼容。 此方法允許自定義特定的仿真，仿真場景，並在一定程度上定制仿真器本身。 這是最簡單，最常用的方法。</span></span></li>
<li><span>an </span><a href="https://www.coppeliarobotics.com/helpFiles/en/addOns.htm">add-on</a><span><span> </span>or<span> </span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/sandboxScript.htm">the sandbox script</a> :該方法允許快速自定義模擬器本身。附件可以自動啟動並在後台運行，也可以被稱為函數。 附加組件不應該特定於特定的仿真或模型，而應提供更通用的，仿真器綁定的功能。</li>
<li><span>a </span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm">plugin</a> :該方法主要包括為CoppeliaSim編寫插件。 通常，插件僅用於通過自定義的Lua命令提供仿真，因此與第一種方法結合使用。 有時，插件用於為CoppeliaSim提供特殊功能，這些功能需要快速的計算能力（腳本在大多數情況下比編譯語言要慢），與硬件設備的特定接口（例如，真實的機器人）或與外界特殊的通信接口。</li>
<li><span>a </span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm">remote API</a> :此方法允許外部應用程序使用遠程API命令以非常簡單的方式連接到CoppeliaSim。</li>
<li><span>a </span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterfaces.htm">ROS node</a><span><span> :這種方法允許外部應用程序通過ROS（機器人操作系統）連接到CoppeliaSim。</span></span></li>
<li><span>a </span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm">BlueZero node</a> :此方法允許外部應用程序通過BlueZero連接到CoppeliaSim。</li>
</ul>
<p>下表詳細描述了每種方法的各自優點和缺點：</p>
<p><img alt="" height="855" src="/images/controlEntities.jpg" width="751"/></p>
<h3>模擬</h3>
<h4><span>Created by </span>40723144廖豪樹</h4>
<p>A simulation in CoppeliaSim can be started, paused and stopped with [Menu bar --&gt; Simulation --&gt; Start/Pause/Stop simulation] or through the related toolbar buttons:</p>
<p>可以使用<span>[菜單欄-&gt;模擬-&gt;開始/暫停/停止模擬</span>]或通過相關的工具欄按鈕來啟動，暫停和停止CoppeliaSim中的模擬：</p>
<p><img alt="" height="83" src="/images/chrome_2020-04-08_09-53-33.png" width="228"/></p>
<p><span>Internally(在內部), the simulator(模擬器) will use additional(額外) intermediate(中間) states in order to correctly(正確地) inform </span><span><a href="https://www.coppeliarobotics.com/helpFiles/en/scripts.htm">scripts</a>(告知腳本)</span><span> or programs about what will happen next. Following state diagram(狀態圖) illustrates(說明) the simulator's internal(內部) states:</span></p>
<p><span>在內部，<span>模擬器將使用其他中間狀態</span>，以正確告知腳本或程序接下來將發生的情況。<span> </span><span>以下<span>狀態圖說明了模擬器的內部狀態</span></span>：</span></p>
<p><span><img alt="" height="361" src="/images/chrome_2020-03-24_01-07-2.png" width="493"/></span></p>
<p>Scripts and programs should<span> alwaysreact(總是反應)</span><span> </span>according to the current system call function and possibly the simulation state in order to<span> </span><span>behave correctly(正確運行)</span>. It is good practice to<span> </span><span>divide each(劃分每個)</span><span> </span>control code into<span> </span><span>at least(至少)</span><span> </span>4 system call functions (e.g. for<span> non-threaded(非線性) </span>child scripts):</p>
<p><span>腳本和程序應始終根據當前系統調用功能以及可能的模擬狀態進行反應</span>，以便正確運行。 優良作法是<span>將每個控制代碼<span>至少分為4個系統調用函數</span></span>（例如，用於非線程子腳本）：</p>
<ul>
<li><strong><span>In</span><span><span>itialization(初始化)</span><span> </span>function:</span></strong><span> </span>sysCall_init: the function is called only when the script is<span><span> </span>initialized(初始化)</span>.</li>
</ul>
<p><strong><span>      初始化函數：</span></strong>sysCall_init：僅在腳本初始化時才調用該函數。</p>
<ul>
<li><strong><span><span>Actuation(激活)</span><span> </span>function:<span> </span></span></strong>sysCall_actuation: the function is called when actuation should happen.</li>
</ul>
<p><strong><span>      激活函數</span></strong>：sysCall_actuation：應在發生激活時調用該函數。</p>
<ul>
<li><strong><span><span>Sensing(感測)<span> </span></span>function:</span><span> </span></strong>sysCall_sensing: this function is called when sensing should happen.</li>
</ul>
<p><strong><span>      感測功能：</span></strong>sysCall_sensing：應在感測發生時調用此函數。</p>
<ul>
<li><strong><span><span>Clean-up(清理)</span><span> </span>function:</span></strong><span> </span>sysCall_cleanup: the function is called just before the script is<span><span> </span>de-initialized(未初始化)</span><span> </span>(e.g. at simulation end, or when the script is<span> </span><span>destroyed(銷毀)</span>).</li>
</ul>
<p><strong><span>      清理函數：</span></strong>sysCall_cleanup：該函數在腳本未初始化之前被調用（例如在模擬結 束時或腳本被銷毀時）。</p>
<p></p>
<h3>Tutorials</h3>
<p><a href="https://www.coppeliarobotics.com/helpFiles/en/tutorials.htm">Tutorials</a></p>
<p><img alt="" height="57" src="/images/chrome_2020-03-24_01-07-28.png" width="249"/></p>
<h2>Webots</h2>
<h1>電子書翻譯</h1>
<h2>Collaboration翻譯</h2>
<p>DigitalProductCollaboration.txt翻譯</p>
<p><span style="color: #ff0000;">Finding and Using the Right Design Collaboration Tools</span></p>
<pre class="tw-data-text tw-text-large tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="zh-TW">尋找和使用正確的設計協同工具<br/></span></pre>
<p><span style="color: #ff0000;">The right tools go a long way in reinforcing your team's design collaboration mindset. In this section, you'll learn what to look for in collaboration tools. We also recommend tools based on our own experiences.</span></p>
<p>正確的工具在增強團隊的設計協同思維方面大有幫助。在這 部分，您將了解在協同工具中尋找什麼。我們還根據我們自己的經驗推薦工具 。</p>
<p><span style="color: #ff0000;">SELECTING THE RIGHT TOOLS</span></p>
<p>選擇對的工具</p>
<p><span style="color: #ff0000;">Effective collaboration tools remove all barriers for collaborators to quickly and easily access and interact with the work. This keeps the focus on giving feedback. They also allow others to collaborate on a design without destroying the original.</span></p>
<p>有效的協同工具為協同者消除了所有障礙，使他們能夠快速輕鬆地存取及工作互動。這是將重點放在提供反饋上。他們還允許其他人 在不破壞原始設計的情況下進行協同。</p>
<p><span style="color: #ff0000;">In the past, we used relied on tools that provided basic versioning control instead of true collaborative features. For example, a designer would save a Sketch file and upload it to Dropbox. Another team member would then download it, work on it, and re-upload it. There was no easy way to make changes while the file was in another's hands. We tried something similar with Github, a tool that proved great for managing codebases, but not so much with iterative design work. Needless to say, these version control processes made our collaboration more time consuming, confusing, and very un-collaborative.</span></p>
<p>過去，我們使用依賴於提供基本版本控制的工具，而不是真正的 協同功能。例如，設計人員保存一個Sketch文件並將其上傳到Dropbox。 然後，另一個團隊成員將它下載，進行處理，然後重新上傳。沒有簡單的方法 在文件移交給他人的情況下進行更改。我們嘗試了與Github類似的方法， 實踐證明，該工具非常適合管理代碼庫，但在疊代設計工作中卻不那麼重要。 更不用說，這些版本控制流程使我們的協作更加耗時，令人困惑，而且非常不協同。</p>
<p><span style="color: #ff0000;">Now we choose from a variety of more advanced tools depending on the type of collaboration we want to achieve.</span></p>
<p>現在，我們想要實現根據協同類型從多種更高級的工具中進行選擇 。</p>
<p><a href="https://www.figma.com/">FIGMA</a></p>
<p>This is a collaboration-first, shared workspace tool. Figma works well for having multiple people in same area of the design file. You can watch teammates design or work together on the same design in real time.</p>
<p>這是一個協同優先的共享工作區工具。 Figma非常適合在其中有多個人 設計文件的相同區域。您可以觀看隊友設計或在同一設計上一起即時工作。</p>
<p>Benefits:</p>
<p><span style="color: #ff0000;">Figma reduces the ability for someone to work in a silo.</span></p>
<p><span style="color: #ff0000;">There's no need to add unnecessary polish or create static deliverables to enable collaboration. So you don't need to change your workflow to show off a design.</span></p>
<p><span style="color: #ff0000;">It's easy to see and interact with the work in its native environment and apply tweaks at will.</span></p>
<p><span style="color: #ff0000;">When to use: Flow docs, high-fidelity wireframes, spur-of-the-moment collaboration, and walking customers through a series of screens to explain and get feedback on design direction.</span></p>
<p>好處 :</p>
<p>Figma降低了某人在孤立單位工作的能力。</p>
<p>無需添加不必要的修飾或創建可交付結果的靜態即可實現協同。因此，您無需更改工作流程即可展示設計。</p>
<p>可以很容易地在其原生環境中看到並與之互動，並隨意進行調整。</p>
<p>何時使用：流動文檔，高保真線框，即時協同和 通過客戶一系列畫面來解釋並獲得有關設計方向的反饋。</p>
<p><a href="https://marvelapp.com/">MARVEL</a></p>
<p><span style="color: #ff0000;">While Figma tends to feel more free-form and flexible, Marvel allows for a more standardized form of collaboration. It also makes it easy on our customers to collaborate with us.</span></p>
<p>雖然Figma傾向於感覺更自由和靈活，但Marvel允許更標準化的形式合作。 這也使我們的客戶可以輕鬆地與我們合作。</p>
<p>Benefits:</p>
<p><span style="color: #ff0000;">Marvel is a cleaner, more formalized and focused space, great for collaborating with non-design team members.</span></p>
<p><span style="color: #ff0000;">It removes all need for the customer to pay for an account or have a deep understanding of the tool to see the work.</span></p>
<p><span style="color: #ff0000;">Customers can download screens and see them in action on a device environment via the Marvel app.</span></p>
<p>好處 :</p>
<p>Marvel是一個更整潔，更規範和專注的空間，非常適合與非設計團隊成員進行協作。</p>
<p>它消除了客戶為帳戶付款或對工具進行深入了解的所有需求。</p>
<p>客戶可以下載螢幕，並通過Marvel應用程序在設備環境中查看它們的運行情況。</p>
<p><span style="color: #ff0000;">When to use: Presenting more finalized design work with customers and developers. (Learn about how Marvel compares with other prototyping tools.)</span></p>
<p>向客戶和開發人員展示更多最終設計工作。（學習關於Marvel與其他原型工具的比較）</p>
<p><span style="color: #ff0000;">OTHER COLLABORATION TOOLS</span></p>
<p>其他協同工具</p>
<p><span style="color: #ff0000;"><a href="https://zeplin.io/">Zeplin</a> is a useful hand-off tool that allows developers to dive into the nitty gritty specs of design work. (We talk more in-depth about Zeplin here.) </span></p>
<p>Zeplin是一個有用的傳遞工具，可讓開發人員深入了解設計工作的細節。（我們在這裡更深入地討論Zeplin。）</p>
<p><span style="color: #ff0000;"><a href="https://quip.com/">Quip</a> is a great platform for brainstorming and product/process documentation. We use it to record and organize all of the context and knowledge that team members need to know when working on a project. It's also useful for brainstorming new ideas that aren't visual-focused.</span></p>
<p>Quip是自由討論和產品/文檔處理的絕佳平台。 我們用它來記錄 並組織團隊成員在項目上需要了解的所有上下文和知識。 對於集思廣益而不是視覺關注的新想法也很有用。</p>
<p><span style="color: #ff0000;">Please note that there are many other tools out there that add similar benefits to collaboration as the ones listed above. This list represents the tools that have worked well for us in our day-to-day collaboration and is not indicative of all the options that might work well for your team.</span></p>
<p>請注意，還有許多其他工具可以為協同增加與上面列出的類似的好處。 該列表代表了在我們日常工作中對我們有效的<span>協同</span>工具，並不表示所有選項都可能對您的團隊有效。</p>
<p><span style="color: #ff0000;">Savvy's Design Collaboration Process in Practice</span></p>
<p>精明的設計合作過程在實踐中</p>
<p><span style="color: #ff0000;">Now let's take the best practices and tools outlined above and show how they fit together in a real-life situation. We'll use the live drawing experience in the Press Play app to demonstrate the importance of design collaboration. This experience involved significant collaboration from a number of team members across disciplines, including a visual designer, UX designer, developer, product manager, and of course, the customer.</span></p>
<p>現在，讓我們採用上面概述的最佳實踐和工具，並展示它們如何在現實生活中融合在一起。 我們將使用Press Play應用程序中的實時繪圖經驗來演示協同設計的重要性。 這種經驗涉及多個學科領域的團隊成員之間的重大協同，其中包括視覺設計師，UX設計人員，開發人員，產品經理，當然還有客戶。</p>
<p><span style="color: #ff0000;">THE CONTEXT AND CHALLENGE</span></p>
<p>環境與挑戰</p>
<p><span style="color: #ff0000;"><a href="https://www.pressplay.cc/">Press Play</a> is a sweepstakes app that holds daily, weekly, and monthly drawings. Users earn tickets by watching ads and enter drawings by selecting five emojis. Winners are then rewarded based on how their choices match up with the drawing's randomly-selected emojis. This particular task had us creating a fun and exciting live experience for users awaiting the results of the live drawing.</span></p>
<p>Press Play是一個抽獎活動應用程序，可保存每日，每周和每月的圖紙。 用戶通過觀看廣告賺取門票，並通過選擇五個表情符號輸入圖紙。 然後，根據獲獎者的選擇與繪畫中隨機選擇的表情符號匹配的方式來獎勵獲獎者。 這項特殊任務使我們為等待現場繪畫結果的用戶創造了一種有趣而激動人心的現場體驗。</p>
<p><span style="color: #ff0000;">It was important for us to create a game-like animation for this experience. We especially wanted to evoke a sense of playfulness and anticipation on the screen where users go to see how their chosen emojis match up with those from the sweepstakes drawing.</span></p>
<p>對於我們來說，為這種體驗創建類似遊戲的動畫非常重要。 我們特別想在螢幕上喚起用戶的嬉戲感和期待感，讓用戶看到他們選擇的表情符號與抽獎活動圖上的表情符號相匹配。</p>
<p><span style="color: #ff0000;">That said, we needed to be mindful of the level of complexity an animation requires and its impact on the overall product's timeline and cost. Our goal was to push the level of fidelity within a reasonable time without significantly impacting the project's budget.</span></p>
<p>就是說，我們需要注意動畫所需的複雜程度及其對整體產品時間表和成本的影響。 我們的目標是在合理的時間內提高保真度，而又不顯著影響項目預算。</p>
<p><span style="color: #ff0000;">THE COLLABORATIVE PROCESS</span></p>
<p>合作過程</p>
<p><span style="color: #ff0000;">Stage 1: Wireframes and Brainstorming</span></p>
<p><span style="color: #ff0000;">First, a Savvy UX designer created Press Play's overall UX and wireframes, determining what screens were needed and the timing for each one. She also put together a rough concept (shown right) for the live drawing animation, expressing initial ideas based on customer's needs and the project's established UX.</span></p>
<p>階段一：框架與自由討論</p>
<p>首先，一位精明的UX設計師創建了Press Play的整體UX和線框，確定需要哪些畫面以及每個畫面的時間安排。 她還為實時繪畫動畫整理了一個粗略的概念（如右圖所示），根據客戶的需求和項目已建立的用戶體驗表達了初步的想法。</p>
<p><span style="color: #ff0000;">She presented the wireframes and the rough animation to the product manager and visual designer. Then all three met with the customer so everyone would hear the feedback directly.</span></p>
<p>她向產品經理和視覺設計師展示了框架和粗糙的動畫。 然後，這三個人都與客戶會面，因此每個人都可以直接聽到回饋。</p>
<p><span style="color: #ff0000;">Stage 2: Research and Context</span></p>
<p><span style="color: #ff0000;">The Savvy visual designer tasked with creating the actual live drawing animation came in with fresh eyes and without much prior knowledge of the Press Play product. To get up to speed, he talked in depth with the UX designer and product manager. He also dedicated additional research time to understand the overall product goals, challenges, and to familiarize himself with the work to date. As mentioned earlier, he was part of the wireframe presentation and present for the customer's feedback. </span></p>
<p>階段二：研究與環境</p>
<p><span>Savvy</span>的視覺設計師負責創建實際的實時繪圖動畫，而他們對Press Play產品的了解卻很少。為了加快速度，他與UX設計師和產品經理進行了深入交流。他還花費額外的研究時間來了解總體產品目標，挑戰並熟悉迄今為止的工作。如前所述，他是展示框架的一部分，並向客戶提出反饋。</p>
<p><span style="color: #ff0000;">With that context, he conducted some additional research more directly related to the task at hand. In doing so, he made sure he understood the live drawing experience requirements, goals, and challenges. He looked at other apps with similar experiences and fidelity and referenced the rough animation to know what exactly the final animation needed to show (in this case, the winning emojis and the user's emoji selections). Before getting too tied to a solution, he met with a Savvy iOS developer to understand technical constraints and considerations.</span></p>
<p>在這種情況下，他進行了一些與手頭任務直接相關的其他研究。通過這樣做，他確保自己了解現場繪畫體驗的要求,目標和挑戰。他查看了具有類似體驗和保真度的其他應用，並參考了粗糙的動畫以了解最終動畫到底需要顯示什麼（在這種情況下，是獲勝的表情符號和用戶的表情符號選擇）。在過於依賴解決方案之前，他會見了一位精明的iOS開發人員，以了解技術限制和注意事項。</p>
<p><span style="color: #ff0000;">Our visual designer and UX designer then brainstormed what was important for the visuals. They agreed that there needed to be a slow reveal to build up suspense / anticipation for the user</span></p>
<p>然後，我們的視覺設計師和UX設計師集思廣益，對視覺效果至關重要。 他們一致認為，需要慢慢進行透露，以便為用戶建立懸念/期待</p>
<p><span style="color: #ff0000;">Stage 3: </span><a href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3">Iteration</a><span style="color: #ff0000;"> and Feedback</span></p>
<p><span style="color: #ff0000;">As our visual designer worked through a number of different directions he tapped the UX designer to chat through his progress and designs in Figma. By talking through the work they spurred more ideas and iterations while making sure they were staying true to customer expectations. With more solid options at hand, he met once again with the iOS developer to make sure everything was in line from a technical perspective.</span></p>
<p>階段三：疊代與反饋</p>
<p>當我們的視覺設計師沿多個不同方向工作時，他邀請了UX設計師來聊聊他在Figma中的進度和設計。 通過討論工作，他們激發了更多的想法和疊代，同時確保它們符合客戶的期望。 有了更多可靠的選擇，他再次與iOS開發人員會面，以確保從技術角度來看一切都符合要求。</p>
<p><span style="color: #ff0000;">Stage 4: Customer Feedback and Development</span></p>
<p><span style="color: #ff0000;">When we landed on several, more finalized versions of the experience, the visual designer walked through them with the customer using Figma. The product manager and UX designer for Press Play provided feedback and guidance as well.</span></p>
<p><span style="color: #ff0000;">Once they all learned what piqued the customer's interest, the visual designer set off to maximize the visuals and make them ready for development. He continued to work with the iOS developer to get the most out of the concept on a technical level.</span></p>
<p>階段四：顧客回饋與發展</p>
<p>當我們找到了幾種最終確定的體驗版本時，視覺設計師使用Figma與客戶一起瀏覽了它們。 Press Play的產品經理和UX設計師也提供了反饋和指導。</p>
<p>一旦他們都了解了引起客戶興趣的東西，視覺設計師便著手使視覺效果最大化，並為開發做好準備。 他繼續與iOS開發人員合作，以在技術層面上充分利用該概念。</p>
<p><span style="color: #ff0000;">THE END RESULT</span></p>
<p><span style="color: #ff0000;">Press Play's live drawing animation is an example of design collaboration at work; a team of cross-discipline experts working together to solve a design and development challenge with bigger implications. Without design collaboration, we wouldn't have discovered the ideal intersection of user experience, visual, and technical.</span></p>
<p>最終結果</p>
<p>Press Play的實時繪圖動畫是工作中設計協作的一個範例。 一支跨學科專家團隊，共同解決具有更大影響的設計和開發挑戰。 沒有協同設計，我們將找不到用戶體驗，視覺和技術之間的理想交匯處。</p>
<p><span style="color: #ff0000;">When the customer saw the animation alive in his app he called it "groundbreaking."</span></p>
<p>當客戶在他的應用程序中看到生動的動畫時，他稱其為“創新的”。</p>
<p><span style="color: #ff0000;">What’s more, the research, collaboration, and creation of this Press Play experience helped us discover a gap in the product’s user journey. Originally, the live drawing’s intent was to be a fun way to show the results to users. As we moved through the design process, we realized that if a user doesn’t watch the live drawing, and they lose, they don’t get to experience an end to their user journey for that drawing.</span></p>
<p>此外，對這種Press Play體驗的研究，協同和創造，幫助我們發現了產品用戶旅程中的空缺。最初，實時繪圖的目的是將結果顯示給用戶的一種有趣的方式。在設計過程中，我們意識到，如果用戶不觀看實時圖形而迷失了方向，?那麼他們就不會體驗到該圖形的用戶旅程。?</p>
<p><span style="color: #ff0000;">From that discovery, we decided to improve the app in a couple of other places as well. We added a results/live drawing element to the Winner’s Circle and a win-lose history section to the User Details side of the app. In the end, design collaboration empowered us to realize this unfulfilled need in the user experience.</span></p>
<p>基於這一發現，我們決定在其他兩個地方也改進該應用程序。 我們在“<span>Winner’s Circle</span>”中添加了一個結果/實時繪圖元素，並在應用程序的“用戶詳細信息”端添加了“輸贏歷史記錄”部分。 最後，協同設計使我們能夠實現用戶體驗中這一未滿足的需求。</p>
<p><span style="color: #ff0000;">Concluding Note</span></p>
<p><span style="color: #ff0000;">It takes design collaboration to tackle the complex, crucial problems that come along with building great products and experiences. By leveraging the specialized expertise of multiple team members across disciplines, design collaboration makes sure teams meet challenges from all perspectives and come to better solutions. With the right mindset, tools, and process, design collaboration empowers teams to go deeper with creative thinking and iteration.</span></p>
<p><span style="color: #ff0000;">We hope this guide gives you a good foundation from which you can build your own effective design collaboration process. You can learn more about design and product strategy on the Savvy blog, and feel free to contact us for help on the Savvy Apps website.</span></p>
<p>結論說明</p>
<p>它需要協同設計來解決構建出色的產品和體驗所伴隨的複雜，關鍵的問題。 通過利用跨學科的多個團隊成員的專業知識，<span>協同設計</span>可確保團隊從各個角度應對挑戰並尋求更好的解決方案。 通過正確的思維方式，工具和流程，<span>協同設計</span>使團隊能夠通過創造性思維和迭代來更深入。</p>
<p>我們希望本指南為您提供一個良好的基礎，您可以以此為基礎建立自己的有效設計協作流程。 您可以在Savvy博客上了解有關設計和產品策略的更多信息，也可以隨時在Savvy Apps網站上與我們聯繫以獲取幫助。</p>
<h1>四輪機器人模擬</h1>
<p><big><big><big>coppelia sim (V-rep)導入模型並模擬</big></big></big></p>
<p><span style="color: #33cccc;"><big><big>模型由<a href="https://s40723147.github.io/cd2020/content/onshape.html" style="color: #33cccc;">40723147</a>繪製</big></big></span></p>
<p>1.開啟<span>coppelia sim 點選 File &gt;&gt; Import &gt;&gt; Mesh... ，導入模型檔案(小組繪製模型為STL檔)</span></p>
<p><span>2.將導入的模型依照旗子母關係擺放</span></p>
<p><span><img alt="" height="207" src="/images/coppeliaSim_2020-05-18_17-46-21.png" width="299"/></span></p>
<p><span>3.新增節點，右鍵點選車輪 &gt;&gt; Add &gt;&gt; Joint &gt;&gt; Revolute</span></p>
<p><span><img alt="" height="245" src="/images/coppeliaSim_2020-05-18_17-52-56.png" width="330"/></span></p>
<p><span>4.將Joint移動至輪胎與輪軸銜接處(<span style="color: #ff0000;">四顆輪胎都要做</span>)</span></p>
<p><span><img alt="" height="184" src="/images/coppeliaSim_2020-05-18_18-01-28.png" width="317"/></span></p>
<p><span>5.調整車子設定，在零件的圖示上 用左鍵快速點及兩下 &gt;&gt; 點選 show dynamic properties dialog &gt;&gt; 勾選 Body is respondable 和 Body is dynamic (<span style="color: #ff0000;">車身和車輪</span>)</span></p>
<p><span><img alt="" height="312" src="/images/coppeliaSim_2020-05-18_18-21-14.png" width="456"/></span></p>
<p><span>6.調整Joint設定，在零件的圖示上 用左鍵快速點及兩下 &gt;&gt; 點選 show dynamic properties dialog &gt;&gt; 勾選 Motor enabled 並給定<span style="color: #0000ff;">速度</span></span></p>
<p><span><img alt="" height="292" src="/images/coppeliaSim_2020-05-18_18-35-24.png" width="458"/></span></p>
<p><span>7.調整後按下star simulation 進行模擬</span></p>
<p><span><img alt="" height="64" src="/images/coppeliaSim_2020-05-18_18-46-26.png" width="64"/></span></p>
<p><big><big><big>對模型加入腳本並編寫程式進行控制</big></big></big></p>
<p>1.對車身零件點右鍵 點選Add &gt;&gt; Associated scrip &gt;&gt; Non threated</p>
<p><img alt="" height="412" src="/images/coppeliaSim_2020-05-18_18-48-38.png" width="454"/></p>
<p>2.<span>用左鍵快速點及兩下圖示</span></p>
<p><span><img alt="" height="82" src="/images/coppeliaSim_2020-05-18_18-54-02.png" width="91"/></span></p>
<p><span>於開啟的視窗即可開始編寫程式</span></p>
<p><span><img alt="" height="385" src="/images/coppeliaSim_2020-05-18_18-55-27.png" width="460"/></span></p>
<p><big><big><big>Remote API</big></big></big></p>
<p>用Remote API取得遠端模擬影像</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/rwATIlMwpFA" width="560"></iframe></p><h2>問題</h2>
<p>1.模型導入後無法正常模擬(程式寫入後,無法控程式寫入後,無法控制)</p><h1>每周進度</h1>
<p>W2</p>
<p><a href="https://www.coppeliarobotics.com/helpFiles/index.html">CoppeliaSim User Manual</a> 內容分析</p>
<p>了解製作四輪機器人所需功能</p>
<p>W3</p>
<p><span>了解製作四輪機器人所需功能(<a href="https://www.coppeliarobotics.com/helpFiles/index.html">CoppeliaSim User Manual</a>)</span></p>
<p><span>著手進行機器人製作</span></p>
<p><span>PDF製作(<a href="https://www.coppeliarobotics.com/helpFiles/index.html">CoppeliaSim User Manual</a><span>)</span></span></p>
<p><span>W4 &amp; W5</span></p>
<p><span>PDF製作(<a href="https://www.coppeliarobotics.com/helpFiles/index.html">CoppeliaSim User Manual</a><span>)</span></span></p>
<p><span><a href="https://cyberbotics.com/doc/guide/index">Webots </a>內容分析</span></p>
<p><span>DesignCollaborationBetterProducts 內容翻譯</span></p>
<p><span>W6</span></p>
<p><span><a href="https://cyberbotics.com/doc/guide/index">Webots </a>內容分析</span></p>
<p><span>DesignCollaborationBetterProducts 內容翻譯</span></p>
<p>Assignment 1 總整理</p>
<p><span>W7</span></p>
<p><span>亂數抽選直播</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/HGAWC2Ug95c" width="560"></iframe></span></p>
<p><span>進度回報</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/pLJPncQGdGk" width="560"></iframe></span></p>
<p><span>W10</span></p>
<p><span>Oauth2 client 連線設定</span></p>
<p><span><img alt="" height="259" src="/images/chrome_2020-05-26_19-29-43.png" width="310"/></span></p>
<p><span></span>W12</p>
<p>協同管理網站 : <a href="http://mde.tw/cdaw12-1/content/index.html">http://mde.tw/cdaw12-1/content/index.html</a></p>
<p>倉儲 : <a href="https://github.com/mdecourse/cdaw12-1">https://github.com/mdecourse/cdaw12-1</a></p>
<p>W13</p>
<p>協同管理網站 : <a href="http://mde.tw/cdaw13-3/content/index.html">http://mde.tw/cdaw13-3/content/index.html</a></p>
<p>倉儲 : <a href="https://github.com/mdecourse/cdaw13-3">https://github.com/mdecourse/cdaw13-3</a></p>
<p>4輪車模擬問題:</p>
<p>1.尺寸問題(公英制混用)</p>
<p>2.Remote API</p>
<p>車輪與底盤配合(以解決)</p>
<p><big><big>VirtualBox網路設定</big></big></p>
<p>新增網路設定</p>
<p><img alt="" height="188" src="/images/VirtualBox_2020-06-03_01-44-50.png" width="278"/></p>
<p><span>設定Port號(IPv4 &amp; IPv6)</span></p>
<p><span><img alt="" height="283" src="/images/VirtualBox_2020-06-03_02-14-34.png" width="422"/></span></p>
<p><span><img alt="" height="282" src="/images/VirtualBox_2020-06-03_02-14-42.png" width="422"/></span></p>
<p><span></span></p>
<p>IP 查詢使用:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">ifconfig</pre>
<p>*若遇到Proxy問題</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">cd /etc/apt/apt.conf.d
sudo vi proxy.conf

#案I鍵進入編輯輸入以下內容:(編輯完成後按ESC&gt;&gt;:wq儲存編輯)
Acquire::http::proxy "http://[2001:288:6004:17::port號]:3128";

更新apt
sudo apt update
</pre>
<p>*ipv6環境設定</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">cd /etc/netplan

sudo vi 00-installer-config.yaml

#按I健進入編輯,ESC退出,:wq儲存
# This is the network config written by 'subiquity'
network:
    ethernets:
        enpes3:
            dhcp4: true
            dhcp6: true
            nameservers:
                addresses:
                    - 2001:b000:168::1
    version: 2

sudo netplan apply</pre>
<p>W14</p>
<p>IPv6設置</p>
<p>依照<a href="https://github.com/mdecourse/cd2020/blob/master/downloads/w13_ipv6_assignment.txt">老師說明</a>設定IPv6:</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">2001:288:6004:17:2020:1::7148/64

gateway: 2001:288:6006:17::254

dns: 
2001:288:6004:1::2
2001:288:6004:17::2
2001:288:6004:17::3 
2001:b000:168::1

"c:\Program Files\Oracle\VirtualBox\VBoxManage.exe" internalcommands sethduuid Ubwcm_w13.vdi</pre>
<p></p>